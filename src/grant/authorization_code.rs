//! Authorization Code Grant.
//!
//! See: <https://datatracker.ietf.org/doc/html/rfc6749#section-4.1>
use iref::{Uri, UriBuf, uri::QueryBuf};
use serde::{Deserialize, Serialize};
use serde_with::skip_serializing_none;

use crate::{
	IntoScope, ScopeBuf,
	client::{OAuth2Client, OAuth2ClientError},
	endpoints::{
		Redirect, Request, SendRequest, Stateful,
		authorization::{
			AuthorizationEndpoint, AuthorizationEndpointLike, AuthorizationRequestBuilder,
		},
		token::{TokenEndpoint, TokenResponse},
	},
	http::{self, APPLICATION_JSON, expect_content_type, header},
	server::ErrorResponse,
	util::extend_uri_query,
};

impl<'a, C> AuthorizationEndpoint<'a, C>
where
	C: OAuth2Client,
{
	pub fn exchange_code(
		self,
		redirect_uri: Option<UriBuf>,
		scope: impl IntoScope,
	) -> AuthorizationRequestBuilder<'a, C, AuthorizationCodeAuthorizationRequest> {
		AuthorizationRequestBuilder::new(
			self,
			AuthorizationCodeAuthorizationRequest::new(
				self.client.client_id().to_owned(),
				redirect_uri,
				scope,
			),
		)
	}
}

pub trait ExchangeCode: AuthorizationEndpointLike {
	fn exchange_code(
		self,
		redirect_uri: Option<UriBuf>,
		scope: impl IntoScope,
	) -> Self::RequestBuilder<AuthorizationCodeAuthorizationRequest>;
}

impl<T: AuthorizationEndpointLike> ExchangeCode for T {
	fn exchange_code(
		self,
		redirect_uri: Option<UriBuf>,
		scope: impl IntoScope,
	) -> Self::RequestBuilder<AuthorizationCodeAuthorizationRequest> {
		let client_id = self.client().client_id().to_owned();
		self.build_request(AuthorizationCodeAuthorizationRequest::new(
			client_id,
			redirect_uri,
			scope,
		))
	}
}

/// Authorization Request with the Authorization Code Grant.
///
/// See: <https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1>
#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
#[serde(tag = "response_type", rename = "code")]
pub struct AuthorizationCodeAuthorizationRequest {
	/// Client identifier.
	///
	/// See: <https://datatracker.ietf.org/doc/html/rfc6749#section-2.2>
	pub client_id: String,

	/// Redirect URI.
	///
	/// See: <https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2>
	pub redirect_uri: Option<UriBuf>,

	/// Scope of the access request.
	///
	/// See: <https://datatracker.ietf.org/doc/html/rfc6749#section-3.3>
	pub scope: Option<ScopeBuf>,
}

impl AuthorizationCodeAuthorizationRequest {
	pub fn new(client_id: String, redirect_uri: Option<UriBuf>, scope: impl IntoScope) -> Self {
		Self {
			client_id,
			redirect_uri,
			scope: scope.into_scope(),
		}
	}

	pub fn redirect_url<'a>(&'a self, default_uri: Option<&'a Uri>) -> Option<&'a Uri> {
		self.redirect_uri.as_deref().or(default_uri)
	}

	pub fn grant(
		self,
		state: Option<String>,
		code: String,
		default_uri: Option<&Uri>,
	) -> Option<UriBuf> {
		let mut url = self.redirect_url(default_uri)?.to_owned();

		extend_uri_query(
			&mut url,
			Stateful::new(AuthorizationCodeAuthorizationResponse { code }, state),
		);

		Some(url)
	}

	pub fn deny<T>(
		self,
		state: Option<String>,
		error: ErrorResponse<T>,
		redirect_uri: Option<&Uri>,
	) -> Option<UriBuf>
	where
		T: Serialize,
	{
		let mut url = self.redirect_url(redirect_uri)?.to_owned();

		extend_uri_query(&mut url, Stateful::new(error, state));

		Some(url)
	}
}

impl Request for AuthorizationCodeAuthorizationRequest {}

impl Redirect for AuthorizationCodeAuthorizationRequest {
	fn build_query(&self) -> QueryBuf {
		QueryBuf::new(serde_html_form::to_string(self).unwrap().into_bytes()).unwrap()
	}
}

/// Authorization Response with the Authorization Code Grant.
#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
pub struct AuthorizationCodeAuthorizationResponse {
	/// Authorization code generated by the authorization server.
	///
	/// The authorization code *must* expire shortly after it is issued to
	/// mitigate the risk of leaks. A maximum authorization code lifetime of
	/// 10 minutes is *recommended*. The client *must not* use the authorization
	/// code more than once. If an authorization code is used more than once,
	/// the authorization server *must* deny the request and *should* revoke
	/// (when possible) all tokens previously issued based on that authorization
	/// code. The authorization code is bound to the client identifier and
	/// redirection URI.
	pub code: String,
}

/// Token Request with the Authorization Code Grant.
#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
#[serde(tag = "grant_type", rename = "authorization_code")]
pub struct AuthorizationCodeTokenRequest {
	/// authorization code received from the authorization server.
	pub code: String,

	/// Redirect URI.
	///
	/// Required if the "redirect_uri" parameter was included in the
	/// authorization request as described in Section 4.1.1, and their values
	/// *must* be identical.
	pub redirect_uri: Option<UriBuf>,

	/// Client identifier.
	///
	/// Required if the client is not authenticating with the authorization
	/// server as described in Section 3.2.1.
	pub client_id: Option<String>,
}

impl Request for AuthorizationCodeTokenRequest {}

impl<'a, C> SendRequest<TokenEndpoint<'a, C>> for AuthorizationCodeTokenRequest {
	type Response = TokenResponse;
	type ResponsePayload = TokenResponse;

	async fn build_request(
		&self,
		endpoint: &TokenEndpoint<'a, C>,
		_http_client: &impl http::HttpClient,
	) -> Result<http::Request<Vec<u8>>, OAuth2ClientError> {
		Ok(http::Request::builder()
			.uri(endpoint.uri.as_str())
			.header(header::CONTENT_TYPE, APPLICATION_JSON)
			.body(serde_json::to_vec(self).unwrap())
			.unwrap())
	}

	fn parse_response(
		&self,
		_endpoint: &TokenEndpoint<'a, C>,
		response: http::Response<Vec<u8>>,
	) -> Result<http::Response<Self::ResponsePayload>, OAuth2ClientError> {
		if response.status() != http::StatusCode::OK {
			return Err(OAuth2ClientError::ServerError(response.status()));
		}

		expect_content_type(response.headers(), &APPLICATION_JSON)?;

		let body = serde_json::from_slice(response.body()).map_err(OAuth2ClientError::response)?;

		Ok(response.map(|_| body))
	}

	async fn process_response(
		&self,
		_endpoint: &TokenEndpoint<'a, C>,
		_http_client: &impl crate::http::HttpClient,
		response: http::Response<Self::ResponsePayload>,
	) -> Result<Self::Response, OAuth2ClientError> {
		Ok(response.into_body())
	}
}
