//! Authorization Code Grant.
//!
//! See: <https://datatracker.ietf.org/doc/html/rfc6749#section-4.1>
use iref::{Uri, UriBuf};
use serde::{Deserialize, Serialize};
use serde_with::skip_serializing_none;

use crate::{
	ClientIdBuf, CodeBuf, IntoScope, ScopeBuf, StateBuf, Stateful,
	client::{OAuth2Client, OAuth2ClientError},
	endpoints::{
		Redirect, SendRequest,
		authorization::{
			AuthorizationEndpoint, AuthorizationEndpointLike, AuthorizationRequestBuilder,
		},
		token::{TokenEndpoint, TokenRequestBuilder, TokenResponse},
	},
	http::{self, APPLICATION_JSON, WwwFormUrlEncoded, expect_content_type},
	server::ErrorResponse,
	util::extend_uri_query,
};

impl<'a, C> AuthorizationEndpoint<'a, C>
where
	C: OAuth2Client,
{
	pub fn authorize_url(
		self,
		redirect_uri: Option<UriBuf>,
		scope: impl IntoScope,
	) -> AuthorizationRequestBuilder<'a, C, AuthorizationCodeAuthorizationRequest> {
		AuthorizationRequestBuilder::new(
			self,
			AuthorizationCodeAuthorizationRequest::new(
				self.client.client_id().to_owned(),
				redirect_uri,
				scope,
			),
		)
	}
}

pub trait ExchangeCode: AuthorizationEndpointLike {
	fn authorize_url(
		self,
		redirect_uri: Option<UriBuf>,
		scope: impl IntoScope,
	) -> Self::RequestBuilder<AuthorizationCodeAuthorizationRequest>;
}

impl<T: AuthorizationEndpointLike> ExchangeCode for T {
	fn authorize_url(
		self,
		redirect_uri: Option<UriBuf>,
		scope: impl IntoScope,
	) -> Self::RequestBuilder<AuthorizationCodeAuthorizationRequest> {
		let client_id = self.client().client_id().to_owned();
		self.build_request(AuthorizationCodeAuthorizationRequest::new(
			client_id,
			redirect_uri,
			scope,
		))
	}
}

/// Authorization Request with the Authorization Code Grant.
///
/// See: <https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1>
#[skip_serializing_none]
#[derive(Debug, Serialize, Deserialize)]
#[serde(tag = "response_type", rename = "code")]
pub struct AuthorizationCodeAuthorizationRequest {
	/// Client identifier.
	///
	/// See: <https://datatracker.ietf.org/doc/html/rfc6749#section-2.2>
	pub client_id: ClientIdBuf,

	/// Redirect URI.
	///
	/// See: <https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2>
	pub redirect_uri: Option<UriBuf>,

	/// Scope of the access request.
	///
	/// See: <https://datatracker.ietf.org/doc/html/rfc6749#section-3.3>
	pub scope: Option<ScopeBuf>,
}

impl AuthorizationCodeAuthorizationRequest {
	pub fn new(
		client_id: ClientIdBuf,
		redirect_uri: Option<UriBuf>,
		scope: impl IntoScope,
	) -> Self {
		Self {
			client_id,
			redirect_uri,
			scope: scope.into_scope(),
		}
	}

	pub fn redirect_url<'a>(&'a self, default_uri: Option<&'a Uri>) -> Option<&'a Uri> {
		self.redirect_uri.as_deref().or(default_uri)
	}

	pub fn grant(
		self,
		state: Option<StateBuf>,
		code: CodeBuf,
		default_uri: Option<&Uri>,
	) -> Option<UriBuf> {
		let mut url = self.redirect_url(default_uri)?.to_owned();

		extend_uri_query(
			&mut url,
			Stateful::new(AuthorizationCodeAuthorizationResponse { code }, state),
		);

		Some(url)
	}

	pub fn deny<T>(
		self,
		state: Option<StateBuf>,
		error: ErrorResponse<T>,
		redirect_uri: Option<&Uri>,
	) -> Option<UriBuf>
	where
		T: Serialize,
	{
		let mut url = self.redirect_url(redirect_uri)?.to_owned();

		extend_uri_query(&mut url, Stateful::new(error, state));

		Some(url)
	}
}

impl Redirect for AuthorizationCodeAuthorizationRequest {
	type RequestBody<'b>
		= &'b Self
	where
		Self: 'b;

	fn build_query(&self) -> Self::RequestBody<'_> {
		self
	}
}

/// Authorization Response with the Authorization Code Grant.
#[skip_serializing_none]
#[derive(Serialize, Deserialize)]
pub struct AuthorizationCodeAuthorizationResponse {
	/// Authorization code generated by the authorization server.
	///
	/// The authorization code *must* expire shortly after it is issued to
	/// mitigate the risk of leaks. A maximum authorization code lifetime of
	/// 10 minutes is *recommended*. The client *must not* use the authorization
	/// code more than once. If an authorization code is used more than once,
	/// the authorization server *must* deny the request and *should* revoke
	/// (when possible) all tokens previously issued based on that authorization
	/// code. The authorization code is bound to the client identifier and
	/// redirection URI.
	pub code: CodeBuf,
}

impl<'a, C> TokenEndpoint<'a, C>
where
	C: OAuth2Client,
{
	pub fn exchange_code(
		self,
		code: CodeBuf,
		redirect_uri: Option<UriBuf>,
	) -> TokenRequestBuilder<'a, C, AuthorizationCodeTokenRequest> {
		let client_id = self.client.client_id().to_owned();
		self.begin(AuthorizationCodeTokenRequest::new(
			Some(client_id),
			code,
			redirect_uri,
		))
	}
}

/// Token Request with the Authorization Code Grant.
#[skip_serializing_none]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "grant_type", rename = "authorization_code")]
pub struct AuthorizationCodeTokenRequest {
	/// Client identifier.
	///
	/// Required if the client is not authenticating with the authorization
	/// server as described in Section 3.2.1.
	pub client_id: Option<ClientIdBuf>,

	/// authorization code received from the authorization server.
	pub code: CodeBuf,

	/// Redirect URI.
	///
	/// Required if the "redirect_uri" parameter was included in the
	/// authorization request as described in Section 4.1.1, and their values
	/// *must* be identical.
	pub redirect_uri: Option<UriBuf>,
}

impl AuthorizationCodeTokenRequest {
	pub fn new(
		client_id: Option<ClientIdBuf>,
		code: CodeBuf,
		redirect_uri: Option<UriBuf>,
	) -> Self {
		Self {
			client_id,
			code,
			redirect_uri,
		}
	}
}

impl<'a, C> SendRequest<TokenEndpoint<'a, C>> for AuthorizationCodeTokenRequest
where
	C: OAuth2Client,
{
	type ContentType = WwwFormUrlEncoded;
	type RequestBody<'b>
		= &'b AuthorizationCodeTokenRequest
	where
		Self: 'b;
	type Response = TokenResponse<String, C::TokenParams>;
	type ResponsePayload = TokenResponse<String, C::TokenParams>;

	async fn build_request(
		&self,
		endpoint: &TokenEndpoint<'a, C>,
		_http_client: &impl http::HttpClient,
	) -> Result<http::Request<Self::RequestBody<'_>>, OAuth2ClientError> {
		Ok(http::Request::builder()
			.method(http::Method::POST)
			.uri(endpoint.uri.as_str())
			.body(self)
			.unwrap())
	}

	fn decode_response(
		&self,
		_endpoint: &TokenEndpoint<'a, C>,
		response: http::Response<Vec<u8>>,
	) -> Result<http::Response<Self::ResponsePayload>, OAuth2ClientError> {
		if response.status() != http::StatusCode::OK {
			return Err(OAuth2ClientError::server(response.status()));
		}

		expect_content_type(response.headers(), &APPLICATION_JSON)?;

		let body = serde_json::from_slice(response.body()).map_err(OAuth2ClientError::response)?;

		Ok(response.map(|_| body))
	}

	async fn process_response(
		&self,
		_endpoint: &TokenEndpoint<'a, C>,
		_http_client: &impl crate::http::HttpClient,
		response: http::Response<Self::ResponsePayload>,
	) -> Result<Self::Response, OAuth2ClientError> {
		Ok(response.into_body())
	}
}
